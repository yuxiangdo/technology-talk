1.final finally finalize的区别
Final用来修饰类/方法/变量，修饰类时该类不能被其他类继承，类中的方法隐式定义为final方法；修饰方法时，方法不能被重写（覆盖）；修饰成员变量时，赋值后其值不发生变化（基本数据类型，初始化就不能发生变化；引用类型，地址不发生变化，内容可变）
Finally 作为异常处理的一部分，与try catch一起使用，finally中的语句块最终都会执行（不管是否有catch到异常）
Finalize 在Object中定义，每个对象都有这个方法，在对象被回收时调用，可以使对象存活，也可以做些资源释放的动作，只会被调用一次

2.synchronized关键字的作用以及在什么时候使用，concurrent包里面其它的锁
Synchronized可以用来修饰方法或代码块，称为临界区，能保证多线程访问下同一时刻只能有一个线程访问临界区，保证线程安全。
底层是由JVM实现，在编译时往字节码中插入monitorenter和monitorexit实现
Concurrent包结构有5部分：原子类/锁/collection并发集合框架/excutor线程池/同步工具 Lock接口，ReentrantLock重入锁，ReentrantReadWriteLock读写锁
Lock显式的获取和释放锁，没有synchronized便捷，但是拥有锁获取和释放的可操作性、可中断的获取锁、超时获取锁等同步特性
尝试非阻塞地获取锁：当前线程尝试获取锁，如果锁没被其他线程持有，则成功获取到锁
能被中断地获取锁：获取到锁的线程能响应中断，被中断时抛出中断异常并释放锁
超时获取锁：在指定时间内尝试获取锁，如果超时仍无法获取到，则返回

读写锁：重入锁属于排它锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但在写线程访问时，所有的读线程和其他写线程均被阻塞。维护一对锁，读锁和写锁，并发性相比一般排它锁有很大提升
公平锁和非公平锁：先对锁进行获取的请求先满足是公平锁，即锁的获取顺序符合FIFO，避免饿死，但进行了大量线程切换较耗时；默认实现使用非公平锁，极少的线程切换，保证更大吞吐量，可能造成线程饥饿

3、有遇到过死锁的问题吗？（死锁的原理和解决方法）
死锁原理：多线程持有问题，是线程间切换消耗系统性能的一种极端情况，线程间相互等待资源而又不释放自身资源，导致无穷尽的等待，结果任务永远无法执行完成。
死锁的必要条件：互斥条件，一个资源每次只能被一个线程使用；请求和保持条件，一个线程因请求资源而阻塞时，对已获得的资源保持不释放；不剥夺条件，线程获得资源，在未使用完之前，不能强行剥夺；循环等待条件，若干线程之间形成一种头尾相接的循环等待资源关系
解决方式：破坏其中的条件

4、hashmap的实现原理，hashmap和hashtable的区别
Map的实现类，一种键值对的数据存储形式，key不允许重复出现，value任意，key可以为null，非线程安全的 jdk8之前，内部由数组+链表来实现，jdk8对于链表长度超过8的链表将转存为红黑树。
通过hash的方法，put和get存储和获取对象。存储对象时，将key/value传给put方法，计算key的hashcode值的高16位异或低16位，（n-1）&hash得到bucket位置，根据bucket的占用情况自动调整容量（超出负载容量则resize为2倍）。获取对象时，将key传给get，调用hash算法得到bucket值，进一步调用equals方法确定键值对。如果发生碰撞，hashmap通过链表将产生碰撞的元素组织起来，8中如果碰撞冲突的元素超过8，则转为红黑树从而提高搜索速度。
Hashmap的key或value可以为null，而hashtable不可以，线程非安全
Hashtable的方法使用synchronized修饰是线程安全的，性能比hashmap低

5、分库分表优化
6、分布式系统唯一ID的生成
UUID时间粗略有序性/可反解/可制造，占用空间大，导致数据库性能下降，没有有序性，导致b+树索引在写时过多随机写
基于数据库实现：数据库移植/分库分表时麻烦，调整自增步长的方式，但是依赖数据库个数
Twitter的snowflake开源发号器，scala实现，开源的vesta
全局唯一/粗略有序/可反解/可制造/高可用
最大峰值型（秒级有序）：版本（63）类型（62）生成方式（60-61）秒级时间（30-59）序列号（10-29）机器ID（0-9）
最小粒度型（毫秒级有序）：毫秒级时间（20-59）序列号（10-19）机器ID(0-9)
7. 分布式系统如何保证数据一致性
根据CAP理论，一致性、可用性、分区容忍性，CAP只能满足其中的两项。
1、规避分布式事务--业务整合，缺点是把拆分好的业务又耦合在一起，业务职责不清晰，不利于维护
2、eBay模式：需要将处理的任务通过消息日志的方式来异步执行，再通过业务规则自动或人工发起重试，消息日志的方案的核心是保证服务接口的幂等性
3、分布式事务两种解决方式：
1、优先使用异步消息，消费端要实现幂等，幂等的两种方式：业务逻辑保证幂等、增加去重表，消息先入库再异步发送，发送成功后消息删除；2、有的业务不适合异步消息方式，事务的各个参与方需要同步得到结果：每个参与方维护本地事务，最终如果失败则重试或进行补偿操作
4、两阶段提交协议
5、DTS TCC：try、confirm、cancel，一个完整的业务活动有主业务服务和从业务服务，主业务发起并完成整个业务活动，从业务提供TCC型业务操作，业务活动管理器控制业务活动的一致性，登记操作，在活动提交时确认所有的两阶段事务的confirm操作，业务活动取消是调用所有两阶段事务的cancel操作

8. 分布式锁的实现方法
数据库方式：依靠数据库的唯一索引来实现，想要获取锁时，向数据库插入一条记录，成功插入则获取锁，执行完成后删除对应数据来释放锁
Zookeeper方式：分层的文件系统目录树结构，同一目录下只能有一个唯一文件名。创建一个锁目录lock，如果线程a需要获得锁，就在lock目录下创建临时顺序节点，再查询锁目录下所有子节点，找比自己小的兄弟节点，如果不存在，则说明当前线程的顺序号最小；b如果不是最小节点，则设置监听比自己小的节点，a处理完后删除自己节点，b监听到变更事件再次判断自己是不是最小的，是则获得锁
Redis方式：setnx命令实现，key不存在则设置成功，返回true，获取到锁，否则返回false，获取失败，为了防止死锁，再使用expire对key设置超时时间

9. redis的内存模型以及为什么性能这么好（内存数据库，IO多路复用）
10. zookeeper是保存数据的流程（选举算法要知道）
11. 七层/五层架构， 路由器是在哪层， tcp http等各种协议是哪层
七层架构：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
五层架构：应用层、传输层（tcp、udp）、网络层（路由器）、数据链路层、物理层

12. tcp建立连接的过程，断连过程
syn_sent -->SYN(seq=x)
established <-- syn_rcvd(SYN seq=y, ack=x+1)
established --> established (ack=y+1)

FIN_WAIT_1 -->CLOSE_WAIT(FIN seq=x+2 ACK=y+1)
FIN_WAIT_2 <--CLOSE_WAIT(ACK x+3)
TIME_WAIT  <--LASK_ACK(FIN seq=y+1)
TIME_WAIT --> ACK=y+2

13. 第2次挥手的之后，这时候给服务端发大量的包，服务端会怎样处理
14. java的IO模型
15. java内存模型，volatile关键字的作用
16. elasticSearch为什么搜索比较快
17. hbase和hive底层的存储方式


19. spring aop的实现原理（代理有哪些类型，默认的代理是什么）
20. mybatis把查询结果转换成类的流程

注重java基础细节(并发、jvm)和数据库
1、在java api中常用的数据结构有哪些
2、说说对线程安全的理解
3、ThreadLocal数据结构是怎样的，会有什么问题，如何解决
每个Thread（线程）内部都有一个Map结构数据ThreadLocalMap<ThreadLocal, T>，弱引用机制原因，当jvm发现内存不足时，会自动回收弱引用指向的实例内存，
即其线程内部的ThreadLocalMap会释放其对ThreadLocal的引用从而让jvm回收ThreadLocal对象，是回收对ThreadLocal对象，而非整个Entry，所以线程变量中的
值T对象还是在内存中存在的，所以内存泄漏的问题还没有完全解决。接着分析JDK的实现，会发现在调用ThreadLocal.get()或者ThreadLocal.set(T)时都会定期执行回收无效的Entry操作
4、Java自身有哪些保证线程安全的方式
5、JUC中有哪些保证线程安全的方式
6、synchronized和lock有什么区别
7、常用的垃圾回收算法有哪些
8、详细描述CMS和G1垃圾回收器的原理
9、Spring中如何管理事务，有哪些事务传播类型
10、mysql中什么情况下会用不到索引
索引值为null、不适合键值较少的列、前导模糊查询不能利用索引、运算、使用函数、mysql本身估计全表扫描快于索引
11、什么情况下mysql会出现死锁，如何解决
mysql锁有三种级别：页级、表级、行级，两个或以上的session加锁的顺序不一致导致死锁
12、如何使用mysql实现悲观锁和乐观锁
13、如何理解微服务，服务间如何进行通信，RPC原理
RPC远程过程调用，简单、高效、通用，调用者不必去关心网络通信的细节，像调用本地服务一样调用远程服务，在应用层和传输层中间
client、client stub、server stub、server

14、如何做服务发现和服务治理
服务发现：通过服务注册中心，发布服务到注册中心
服务治理：防止业务服务架构腐化，通过服务调用链梳理不合理服务依赖和调用路径，优化服务化架构；
快速故障定界定位；
服务微管控：运行期服务治理，包括限流降级、服务迁入迁出、服务超时控制、智能路由、优先级调度和流量迁移；
服务生命周期管理：包括服务的上线审批、下线通知，服务在线升级，以及线上线下服务文档库的建设
服务降级：
屏蔽降级，由管理员登录服务治理控制台，选择服务降级菜单，指定屏蔽降级策略如返回null、返回指定异常、执行本地mock接口，
屏蔽降级策略下发到注册中心，消费者和提供者更新本地缓存服务信息执行屏蔽降级
容错降级，根据服务调用结果，自动匹配触发，当非核心服务不可用时，可以对故障服务做业务逻辑放通

15、怎么保证服务间接口调用的幂等性
幂等性：f(x)=f(f(x)) ，同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。
幂等的常用思路：
MVCC 多版本并发控制，乐观锁的一种实现，每一个version只有一次执行成功的机会，一旦失败必须重新获取。
去重表：利用数据库表单的特性实现幂等，在表上构建唯一性索引，保证某一类数据一旦执行完毕，则后续同样的请求无法成功写入。
Token机制：每一次操作生成一个唯一性的凭证，token，一旦执行成功则保存执行结果。对重复的请求，返回同一个结果。

蚂蚁金服二面（电话面试，时间在40分钟左右）
注重java基础（并发、JVM）和项目经验
1、HashTable和HashMap的区别，ConcurrentHashmap的实现

2、如果有多个任务执行完成之后再执行某个任务，使用java有多少种实现的方式
3、如何使用线程池，举一个具体的场景
4、分布式事务如何实现
5、服务调用如何保证幂等性
6、说明一下数据库的悲观锁和乐观锁
7、讲一下现在的项目，以及在其中主要承担的角色

蚂蚁金服三面（现场面试，技术+HR，时间在1小时左右）
不会关注太多技术细节，主要关注的是对一些开放性问题的回答思路
1、为什么要在项目中使用Spring
1）方便解耦，简化开发（高内聚、低耦合）
Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理
2）AOP编程的支持
Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能
声明式事务的支持
只需要通过配置就可以完成对事务的管理，而无需手动编程
3）方便集成各种优秀框架
Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis等）的直接支持
4）降低JavaEE API的使用难度
Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低 


2、你常用到的设计有哪些，你认为什么是设计模式
6项基本原则：
单一职能原则：里式替换原则：子类继承/覆盖父类的方法/   依赖倒置的原则：使用接口   接口隔离：接口实现的作用越简单越好
迪米特法则：  类直接的调用，不用知道被调用者其中的信息，使用接口
开闭原则：
单例模式：
工厂模式：
抽象工厂：
模板方法：
建造者模式：
代理模式：事务/日志  静态代理和动态代理  aop使用动态代理， 是oop的补充，当需要为多个不具有继承关系的对象引入同一个公共行为时，如日志/安全检测等，如果在每个对象引用公共行为则产生大量重复代码

3、说说你理解的抽象
抽象类，包含抽象方法的类，无实列，子类继承必须实现抽象方法。把类抽象出来，当作模板，把相似类的某些方法，某些成员变量抽象出来，继承的子类本质上相似，体现is-a，如动物中的dog和cat；
接口：接口的继承更多是行为上的相似，是一种like a的关系，如飞机和鸟都能飞；

3、Spring的事务传播分别有哪些
其中spring七个事物传播属性：
　PROPAGATION_REQUIRED -- 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。
　PROPAGATION_SUPPORTS -- 支持当前事务，如果当前没有事务，就以非事务方式执行。
　PROPAGATION_MANDATORY -- 支持当前事务，如果当前没有事务，就抛出异常。
　PROPAGATION_REQUIRES_NEW -- 新建事务，如果当前存在事务，把当前事务挂起。
　PROPAGATION_NOT_SUPPORTED -- 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
　PROPAGATION_NEVER -- 以非事务方式执行，如果当前存在事务，则抛出异常。
　PROPAGATION_NESTED -- 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，
则进行与PROPAGATION_REQUIRED类似的操作。

五个隔离级别：
ISOLATION_DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.
另外四个与JDBC的隔离级别相对应；
ISOLATION_READ_UNCOMMITTED 这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。
这种隔离级别会产生脏读，不可重复读和幻像读。
ISOLATION_READ_COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取
该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。
ISOLATION_REPEATABLE_READ 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证
一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。
ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，
不可重复读外，还避免了幻像读。

关键词：
1)幻读：事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录；
2)不可重复读取：事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录；
3)脏读：事务1更新了记录，但没有提交，事务2读取了更新后的行，然后事务T1回滚，现在T2读取无效。

18. spring bean 的生命周期，BeanFactory 和ApplicationContext的区别
按照Spring上下文对实例化的Bean进行配置，也就是IOC注入
如果这个Bean实现了BeanNameAware接口，会调用它实现的setBeanName方法，参数为beanID
如果这个Bean实现了BeanFactoryAware接口，会调用它实现的setBeanFatory方法，传递的是spring上下文本身
如果这个Bean实现了ApplicationContextAware接口，会调用setApplicationContext方法，传入spring上下文，可以获取其他Bean
如果这个Bean关联了BeanPostProcessor接口，会调用postProcessBeforeInitialzation方法，用作bean内容的修改，在初始化结束时调用after方法，也用于内存或缓存技术
如果实现了initializingBean接口，调用initializingBean的afterPropertiesSet方法
如果这个Bean在spring配置文件中配置了init-method熟悉会自动调用其配置的初始化方法
如果这个Bean关联了BeanPostProcessor接口，将会调用postAfterInitialization方法
当Bean不再需要，会经过清理阶段，如果Bean实现了DisposableBean接口，会调用其实现的destroy方法
如果在spring配置中配置了destory-method属性，会自动调用其配置的销毁方法

5、为什么要用mysql的索引
快速查找数据，是一种以空间换时间的方式

6、什么是悲观锁和乐观锁，悲观锁的sql是如何写的
悲观锁
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

乐观锁
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

两种锁的使用场景

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适

7、分布式定时任务：分布式场景下定时任务如何在一个触发时刻只有一台服务器在运行。只在一台服务器上执行（单点风险、资源分配不均衡）；通过配置参数分散运行，在代码测判断是否执行任务（单点分析，运维管理难度大）；使用分布式锁


7、Java中使用线程池应该注意些什么


1、java的异常类型
https://www.cnblogs.com/cvst/p/5822373.html

2、session
一类用来在客户端与服务器之间保持状态的解决方案、解决方案的存储结构、一个浏览器窗口打开到关闭期间、面向连接保持状态，httpsession
https://www.cnblogs.com/lonelydreamer/p/6169469.html

3、java锁
https://www.cnblogs.com/qq78292959/p/4252800.html

4、gc原理

5、hashmap

6、aop原理

7、redis同步机制
https://blog.csdn.net/chen134225/article/details/82117262
https://blog.csdn.net/u013679744/article/details/79203933
Redis
Redis常见集群方案
client分片方案、基于代理方案、redis cluster方案，分片是分割数据到多个redis实例的过程，这三种方案差别在分片动作发生在client端、代理端还是redis cluster端。
redis cluster方案，redis默认堆key使用crc16算法计算hash，得到整数值，然后取余槽个数（默认16384）得到对应槽号。



